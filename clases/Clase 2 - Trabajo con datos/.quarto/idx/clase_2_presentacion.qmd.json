{"title":"Clase 2: Trabajo con datos","markdown":{"yaml":{"title":"Clase 2: Trabajo con datos","subtitle":"Conceptos clave de programación para análisis de datos o automatización de procesos","author":"Fundación SOL","date":"05/12/2025","date-format":"dddd, D MMM , YYYY","lang":"es","format":{"revealjs":{"theme":"night","incremental":true,"logo":"img/logoblanco.png"}},"project":{"type":"website","output-dir":"docs"}},"headingText":"Antecedentes de la programación","containsRefs":false,"markdown":"\n\n\n- Una parte relevante de la historia de la programación moderna ha sido su aplicación para el desarrollo tecnológico en la industria, la administración del Estado y la guerra, e incluso el arte.  \n- Un buen ejemplo es uno de los antecedentes directos de los ordenadores modernos, el *Telar de Jacquard* que utilizaba códigos en tarjetas perforadas para definir diseños o el *Motor Analítico* de Babbage.   \n\n---\n\n::: {#fig-telar-jaq}\n[![](img/Telar-de-Jacquard.jpg){width=\"80%\"}](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom)\n\nTelar de Jacquard (1801) - Nota de prensa [(Science and Industry Museum - Manchester)](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom).\n:::\n\n---\n\n::: {#fig-telar-jaq-2}\n[![](img/telar2.png){width=\"48%\"}](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom)\n\nMuestras de tejidos Telar de Jacquard (1801) - Nota de prensa [(Science and Industry Museum - Manchester)](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom).\n:::\n\n---\n\n::: {#fig-telar-jaq-3}\n[![](img/telar3.png){width=\"30%\"}](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom)\n\nMuestras de tarjetas Telar de Jacquard (1801) - Nota de prensa [(Science and Industry Museum - Manchester)](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom).\n:::\n\n---\n\n::: {#fig-telar-jaq-4}\n[![](img/telar4.png){width=\"70%\"}](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom)\n\nMuestras de tejidos Telar de Jacquard (1801) - Nota de prensa [(Science and Industry Museum - Manchester)](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom).\n:::\n\n---\n\n::: {#fig-aengine}\n![](img/analytical-engine.png){width=\"70%\"}\n\nCharles Babbage - Analytical Engine (1837).\n:::\n\n---\n\n::: {#fig-hollerith}\n[![](img/censo1890.png){width=\"70%\"}](https://www.columbia.edu/cu/computinghistory/census-tabulator.html)\n\nMáquina tabuladora Censo (1890) - Hollerith [(Columbia Edu)](https://www.columbia.edu/cu/computinghistory/census-tabulator.html).\n:::\n\n## Hollerith y el Censo de 1890\n\n- La máquina de Hollerith permitió a la oficina de estadísticas de Estados Unidos finalizar el censo en 6 meses y 2 años de análisis de datos. En referencia al censo de 1880 fue un exito considerando que este demoró 8 años. \n- El uso de tarjetas perforadas se mantuvo en el desarrollo de la computación, programación y análisis de datos, con aplicaciones concretas. Una de las empresas asociadas al uso de esta máquina fue la multinacional IBM.\n\n---\n\n::: {#fig-punchedc}\n![](img/punchedcard.png){width=\"70%\"}\n\nTarjetas perforadas - IBM (siglo XX).\n:::\n\n## La programación y sus aplicaciones \n\n- Estos ejemplos muestran como la programación ha estado relacionada desde sus origenes con la automatización de procesos (sobre todo en el ámbito industrial) y el análisis de datos sociodemográficos para la administración del Estado. \n- Otro caso relevante, es el uso militar de la tecnología de programación y computación, donde la Máquina de Turing (1936). Acá el desafío es no solo el cálculo sino también el manejo de valores lógicos, más cercano a la computación actual.  \n\n## Programación y algortimos\n\n- El primer algoritmo escrito directamente para una computación automatizada es el algoritmo publicado por **Ada Lovelace** en 1843 para el cálculo de números de Bernoulli. \n- Charles Babbage fue invitado a explicar el funcionamiento de la *Analytical Engine* y un matemático, Luigi Menabrea, escribió una nota al respecto en francés. Se pidió a Ada la traducción y que añadiera notas. Estas eran 3 veces más largas que el artículo original. \n\n## Programación y algortimos\n\n- En la Nota G, Lovelace describe como puede hacerse uso de esta máquina, mediante su operación binaria, para realizar cómputos avanzados. \n- La ecuación propuesta era recursiva, pues utilizaba la información de una operación para realizar la siguiente. \n- Según la autora, al hacer un uso binario de las tarjetas perforadas, se abrían posibilidades como el componer y elaborar *piezas científicas de música* de cualquier grado de complejidad.    \n\n---\n\n::: {#fig-punchedc}\n![](img/ada.jpg){width=\"70%\"}\n\nAda Lovelave - 1834\n:::\n\n## ¿Cómo utilizar funciones y algoritmos?\n\n- Recordemos que un *algoritmo* es una serie de instrucciones paso a paso para resolver un problema o realizar una tarea.\n- Una *función* es una forma concreta de escribir y reutilizar ese algoritmo dentro de un programa.\n- ¿Cómo podemos recurrir al uso de funciones y algoritmos para nuestro trabajo cotidiano?\n- ¿Qué procesos nos pueden ayudar a automatizar?  \n- ¿Que son los loops o iteraciones de código?\n\n## Funciones en R\n\n- En este caso entenderemos una función como un código para ser usado con una variedad de imputs y evita que debamos escribir el mismo código una y otra vez.\n- Recordemos que R es un lenguaje de programación entre otros lenguajes existentes como Python, C, etc. \n- Cada lenguaje de programación tiene reglas y formas de programación que definen estilos y formas particulares.\n\n## Estructura de una función básica\n\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nnombre<-function(variables){\ncuerpo\n}\n\n```\n\n## Ejemplo con dataset df_personas\n\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\ndf_personas <- data.frame(\n  ID = 1:10,\n  Nombre = c(\"Ana\",\"Luis\",\"Eva\",\"Diego\",\"Juan\",\"Marcela\",\"Diego\",\"Jocelyn\",\"Raquel\",\"Alejandra\"),\n  Edad = c(28,34,39,45,14,65,52,27,62,28),\n  Ocupación = c(TRUE,TRUE,FALSE,TRUE,FALSE,FALSE,TRUE,FALSE,FALSE,TRUE),\n  Ingreso = c(510636,600000,80000,420000,224004,70000,530000,50000,224004,380000),\n  Gasto = c(700000,900000,120000,920000,200000,300000,1130000,600000,700000,880000)\n)\n```\n\n## Función ejemplo para estadísticas de resumen\n\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\n#Escribimos la función\nresumen <- function(vector){\n    maximo <-max(vector)\n    media <-mean(vector)\n    mediana <- median(vector)\n    minimo <- min(vector)\n    return(c(maximo,media,mediana,minimo))\n}\n```\n\n## Función aplicamos función a vectores edad, ingreso y gasto\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\n#Aplicamos sobre el vector \nedad<-as.vector(df_personas$Edad)\nprint(resumen(edad))\ningreso<-as.vector(df_personas$Ingreso)\nprint(resumen(ingreso))\ngasto<-as.vector(df_personas$Gasto)\nprint(resumen(gasto))\n\n```\n\n## Función intervalo de confianza\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nmean_ci <- function(x, conf = 0.95) {\n  se <- sd(x) / sqrt(length(x))\n  alpha <- 1 - conf\n  mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))\n}\n```\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nmean_ci(edad)\nmean_ci(ingreso)\nmean_ci(gasto)\n```\n\n## Funciones anidadas\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nresumen <- function(vector){\n  mean_ci <- function(x, conf = 0.95) {\n  se <- sd(x) / sqrt(length(x))\n  alpha <- 1 - conf\n  mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))\n  }\n    interval <-mean_ci(vector)\n    maximo <-max(vector)\n    media <-mean(vector)\n    mediana <- median(vector)\n    minimo <- min(vector)\n    return(c(maximo,media,mediana,minimo,interval))\n}\n```\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nprint(resumen(edad))\nprint(resumen(ingreso))\nprint(resumen(gasto))\n```\n## Aplicar una función a una lista de vectores\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nlista<-list(a=edad,b=ingreso,c=gasto)\nlapply(lista,resumen)\n```\n\n## ¿Qué es un loop?\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nfor (i in 1:5) {\n  print(i)\n}\n```\n\n## Siguiendo el ejemplo anterior, en lugar de lapply con un loop\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nfor (element in lista) {\n  print(resumen(element))\n}\n```\n\n## Aplicar función según condición \n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nocupa <- ifelse(df_personas$Ocupación == TRUE, \"Ocupado/a\", \"No ocupado/a\")\nocupa2 <-as.vector(df_personas$Ocupación)\nocupa2\n```\n\n","srcMarkdownNoYaml":"\n\n## Antecedentes de la programación\n\n- Una parte relevante de la historia de la programación moderna ha sido su aplicación para el desarrollo tecnológico en la industria, la administración del Estado y la guerra, e incluso el arte.  \n- Un buen ejemplo es uno de los antecedentes directos de los ordenadores modernos, el *Telar de Jacquard* que utilizaba códigos en tarjetas perforadas para definir diseños o el *Motor Analítico* de Babbage.   \n\n---\n\n::: {#fig-telar-jaq}\n[![](img/Telar-de-Jacquard.jpg){width=\"80%\"}](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom)\n\nTelar de Jacquard (1801) - Nota de prensa [(Science and Industry Museum - Manchester)](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom).\n:::\n\n---\n\n::: {#fig-telar-jaq-2}\n[![](img/telar2.png){width=\"48%\"}](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom)\n\nMuestras de tejidos Telar de Jacquard (1801) - Nota de prensa [(Science and Industry Museum - Manchester)](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom).\n:::\n\n---\n\n::: {#fig-telar-jaq-3}\n[![](img/telar3.png){width=\"30%\"}](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom)\n\nMuestras de tarjetas Telar de Jacquard (1801) - Nota de prensa [(Science and Industry Museum - Manchester)](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom).\n:::\n\n---\n\n::: {#fig-telar-jaq-4}\n[![](img/telar4.png){width=\"70%\"}](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom)\n\nMuestras de tejidos Telar de Jacquard (1801) - Nota de prensa [(Science and Industry Museum - Manchester)](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom).\n:::\n\n---\n\n::: {#fig-aengine}\n![](img/analytical-engine.png){width=\"70%\"}\n\nCharles Babbage - Analytical Engine (1837).\n:::\n\n---\n\n::: {#fig-hollerith}\n[![](img/censo1890.png){width=\"70%\"}](https://www.columbia.edu/cu/computinghistory/census-tabulator.html)\n\nMáquina tabuladora Censo (1890) - Hollerith [(Columbia Edu)](https://www.columbia.edu/cu/computinghistory/census-tabulator.html).\n:::\n\n## Hollerith y el Censo de 1890\n\n- La máquina de Hollerith permitió a la oficina de estadísticas de Estados Unidos finalizar el censo en 6 meses y 2 años de análisis de datos. En referencia al censo de 1880 fue un exito considerando que este demoró 8 años. \n- El uso de tarjetas perforadas se mantuvo en el desarrollo de la computación, programación y análisis de datos, con aplicaciones concretas. Una de las empresas asociadas al uso de esta máquina fue la multinacional IBM.\n\n---\n\n::: {#fig-punchedc}\n![](img/punchedcard.png){width=\"70%\"}\n\nTarjetas perforadas - IBM (siglo XX).\n:::\n\n## La programación y sus aplicaciones \n\n- Estos ejemplos muestran como la programación ha estado relacionada desde sus origenes con la automatización de procesos (sobre todo en el ámbito industrial) y el análisis de datos sociodemográficos para la administración del Estado. \n- Otro caso relevante, es el uso militar de la tecnología de programación y computación, donde la Máquina de Turing (1936). Acá el desafío es no solo el cálculo sino también el manejo de valores lógicos, más cercano a la computación actual.  \n\n## Programación y algortimos\n\n- El primer algoritmo escrito directamente para una computación automatizada es el algoritmo publicado por **Ada Lovelace** en 1843 para el cálculo de números de Bernoulli. \n- Charles Babbage fue invitado a explicar el funcionamiento de la *Analytical Engine* y un matemático, Luigi Menabrea, escribió una nota al respecto en francés. Se pidió a Ada la traducción y que añadiera notas. Estas eran 3 veces más largas que el artículo original. \n\n## Programación y algortimos\n\n- En la Nota G, Lovelace describe como puede hacerse uso de esta máquina, mediante su operación binaria, para realizar cómputos avanzados. \n- La ecuación propuesta era recursiva, pues utilizaba la información de una operación para realizar la siguiente. \n- Según la autora, al hacer un uso binario de las tarjetas perforadas, se abrían posibilidades como el componer y elaborar *piezas científicas de música* de cualquier grado de complejidad.    \n\n---\n\n::: {#fig-punchedc}\n![](img/ada.jpg){width=\"70%\"}\n\nAda Lovelave - 1834\n:::\n\n## ¿Cómo utilizar funciones y algoritmos?\n\n- Recordemos que un *algoritmo* es una serie de instrucciones paso a paso para resolver un problema o realizar una tarea.\n- Una *función* es una forma concreta de escribir y reutilizar ese algoritmo dentro de un programa.\n- ¿Cómo podemos recurrir al uso de funciones y algoritmos para nuestro trabajo cotidiano?\n- ¿Qué procesos nos pueden ayudar a automatizar?  \n- ¿Que son los loops o iteraciones de código?\n\n## Funciones en R\n\n- En este caso entenderemos una función como un código para ser usado con una variedad de imputs y evita que debamos escribir el mismo código una y otra vez.\n- Recordemos que R es un lenguaje de programación entre otros lenguajes existentes como Python, C, etc. \n- Cada lenguaje de programación tiene reglas y formas de programación que definen estilos y formas particulares.\n\n## Estructura de una función básica\n\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nnombre<-function(variables){\ncuerpo\n}\n\n```\n\n## Ejemplo con dataset df_personas\n\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\ndf_personas <- data.frame(\n  ID = 1:10,\n  Nombre = c(\"Ana\",\"Luis\",\"Eva\",\"Diego\",\"Juan\",\"Marcela\",\"Diego\",\"Jocelyn\",\"Raquel\",\"Alejandra\"),\n  Edad = c(28,34,39,45,14,65,52,27,62,28),\n  Ocupación = c(TRUE,TRUE,FALSE,TRUE,FALSE,FALSE,TRUE,FALSE,FALSE,TRUE),\n  Ingreso = c(510636,600000,80000,420000,224004,70000,530000,50000,224004,380000),\n  Gasto = c(700000,900000,120000,920000,200000,300000,1130000,600000,700000,880000)\n)\n```\n\n## Función ejemplo para estadísticas de resumen\n\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\n#Escribimos la función\nresumen <- function(vector){\n    maximo <-max(vector)\n    media <-mean(vector)\n    mediana <- median(vector)\n    minimo <- min(vector)\n    return(c(maximo,media,mediana,minimo))\n}\n```\n\n## Función aplicamos función a vectores edad, ingreso y gasto\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\n#Aplicamos sobre el vector \nedad<-as.vector(df_personas$Edad)\nprint(resumen(edad))\ningreso<-as.vector(df_personas$Ingreso)\nprint(resumen(ingreso))\ngasto<-as.vector(df_personas$Gasto)\nprint(resumen(gasto))\n\n```\n\n## Función intervalo de confianza\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nmean_ci <- function(x, conf = 0.95) {\n  se <- sd(x) / sqrt(length(x))\n  alpha <- 1 - conf\n  mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))\n}\n```\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nmean_ci(edad)\nmean_ci(ingreso)\nmean_ci(gasto)\n```\n\n## Funciones anidadas\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nresumen <- function(vector){\n  mean_ci <- function(x, conf = 0.95) {\n  se <- sd(x) / sqrt(length(x))\n  alpha <- 1 - conf\n  mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))\n  }\n    interval <-mean_ci(vector)\n    maximo <-max(vector)\n    media <-mean(vector)\n    mediana <- median(vector)\n    minimo <- min(vector)\n    return(c(maximo,media,mediana,minimo,interval))\n}\n```\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nprint(resumen(edad))\nprint(resumen(ingreso))\nprint(resumen(gasto))\n```\n## Aplicar una función a una lista de vectores\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nlista<-list(a=edad,b=ingreso,c=gasto)\nlapply(lista,resumen)\n```\n\n## ¿Qué es un loop?\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nfor (i in 1:5) {\n  print(i)\n}\n```\n\n## Siguiendo el ejemplo anterior, en lugar de lapply con un loop\n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nfor (element in lista) {\n  print(resumen(element))\n}\n```\n\n## Aplicar función según condición \n```{r}\n#| echo: TRUE\n#| eval: TRUE\n#| code-line-numbers: \"1\"\nocupa <- ifelse(df_personas$Ocupación == TRUE, \"Ocupado/a\", \"No ocupado/a\")\nocupa2 <-as.vector(df_personas$Ocupación)\nocupa2\n```\n\n"},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","incremental":true,"output-file":"clase_2_presentacion.html"},"language":{"toc-title-document":"Tabla de contenidos","toc-title-website":"En esta página","related-formats-title":"Otros formatos","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Fuente","other-links-title":"Otros Enlaces","code-links-title":"Enlaces de código","launch-dev-container-title":"Iniciar Dev Container","launch-binder-title":"Iniciar Binder","article-notebook-label":"Cuaderno de Artículo","notebook-preview-download":"Descargar Cuaderno","notebook-preview-download-src":"Descargar código fuente","notebook-preview-back":"Volver al Artículo","manuscript-meca-bundle":"Archivo MECA","section-title-abstract":"Resumen","section-title-appendices":"Apéndices","section-title-footnotes":"Notas","section-title-references":"Referencias","section-title-reuse":"Reutilización","section-title-copyright":"Derechos de autor","section-title-citation":"Cómo citar","appendix-attribution-cite-as":"Por favor, cita este trabajo como:","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Ver Licencia","title-block-author-single":"Autor/a","title-block-author-plural":"Autores/as","title-block-affiliation-single":"Afiliación","title-block-affiliation-plural":"Afiliaciones","title-block-published":"Fecha de publicación","title-block-modified":"Fecha de modificación","title-block-keywords":"Palabras clave","callout-tip-title":"Tip","callout-note-title":"Nota","callout-warning-title":"Advertencia","callout-important-title":"Importante","callout-caution-title":"Precaución","code-summary":"Código","code-tools-menu-caption":"Código","code-tools-show-all-code":"Mostrar todo el código","code-tools-hide-all-code":"Ocultar todo el código","code-tools-view-source":"Ver el código fuente","code-tools-source-code":"Ejecutar el código","tools-share":"Compartir","tools-download":"Descargar","code-line":"Línea","code-lines":"Líneas","copy-button-tooltip":"Copiar al portapapeles","copy-button-tooltip-success":"Copiado","repo-action-links-edit":"Editar esta página","repo-action-links-source":"Ver el código","repo-action-links-issue":"Informar de un problema","back-to-top":"Volver arriba","search-no-results-text":"Sin resultados","search-matching-documents-text":"documentos encontrados","search-copy-link-title":"Copiar el enlace en la búsqueda","search-hide-matches-text":"Ocultar resultados adicionales","search-more-match-text":"resultado adicional en este documento","search-more-matches-text":"resultados adicionales en este documento","search-clear-button-title":"Borrar","search-text-placeholder":"","search-detached-cancel-button-title":"Cancelar","search-submit-button-title":"Enviar","search-label":"Buscar","toggle-section":"Alternar sección","toggle-sidebar":"Alternar barra lateral","toggle-dark-mode":"Alternar modo oscuro","toggle-reader-mode":"Alternar modo lector","toggle-navigation":"Navegación de palanca","crossref-fig-title":"Figura","crossref-tbl-title":"Tabla","crossref-lst-title":"Listado","crossref-thm-title":"Teorema","crossref-lem-title":"Lema","crossref-cor-title":"Corolario","crossref-prp-title":"Proposición","crossref-cnj-title":"Conjetura","crossref-def-title":"Definición","crossref-exm-title":"Ejemplo","crossref-exr-title":"Ejercicio","crossref-ch-prefix":"Capítulo","crossref-apx-prefix":"Apéndice","crossref-sec-prefix":"Sección","crossref-eq-prefix":"Ecuación","crossref-lof-title":"Listado de Figuras","crossref-lot-title":"Listado de Tablas","crossref-lol-title":"Listado de Listados","environment-proof-title":"Prueba","environment-remark-title":"Observación","environment-solution-title":"Solución","listing-page-order-by":"Ordenar por","listing-page-order-by-default":"Por defecto","listing-page-order-by-date-asc":"Menos reciente","listing-page-order-by-date-desc":"Más reciente","listing-page-order-by-number-desc":"De mayor a menor","listing-page-order-by-number-asc":"De menor a mayor","listing-page-field-date":"Fecha","listing-page-field-title":"Título","listing-page-field-description":"Descripción","listing-page-field-author":"Autor/a","listing-page-field-filename":"Nombre de archivo","listing-page-field-filemodified":"Fecha de modificación","listing-page-field-subtitle":"Subtítulo","listing-page-field-readingtime":"Tiempo de lectura","listing-page-field-wordcount":"Conteo de Palabras","listing-page-field-categories":"Categorías","listing-page-minutes-compact":"{0} minutos","listing-page-category-all":"Todas","listing-page-no-matches":"No hay resultados","listing-page-words":"{0} palabras","listing-page-filter":"Filtro","draft":"Borrador"},"metadata":{"lang":"es","fig-responsive":false,"quarto-version":"1.6.33","auto-stretch":true,"title":"Clase 2: Trabajo con datos","subtitle":"Conceptos clave de programación para análisis de datos o automatización de procesos","author":"Fundación SOL","date":"05/12/2025","date-format":"dddd, D MMM , YYYY","theme":"night","logo":"img/logoblanco.png"}}},"projectFormats":[]}