{
  "hash": "91785ee18dc62ac0a52f7459c28ce096",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Clase 2: Trabajo con datos\"\nsubtitle: \"Conceptos clave de programación para análisis de datos o automatización de procesos\"\nauthor: \"Fundación SOL\"\ndate: 05/12/2025\ndate-format: \"dddd, D MMM , YYYY\"\nlang: es\nformat:\n  pdf:\n    incremental: true\n    logo: img/logoblanco.png\nproject:\n  type: website\n  output-dir: docs\n---\n\n\n\n## Antecedentes de la programación\n\n- Una parte relevante de la historia de la programación moderna ha sido su aplicación para el desarrollo tecnológico en la industria, la administración del Estado y la guerra, e incluso el arte.  \n- Un buen ejemplo es uno de los antecedentes directos de los ordenadores modernos, el *Telar de Jacquard* que utilizaba códigos en tarjetas perforadas para definir diseños o el *Motor Analítico* de Babbage.   \n\n---\n\n::: {#fig-telar-jaq}\n[![](img/Telar-de-Jacquard.jpg){width=\"80%\"}](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom)\n\nTelar de Jacquard (1801) - Nota de prensa [(Science and Industry Museum - Manchester)](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom).\n:::\n\n---\n\n::: {#fig-telar-jaq-2}\n[![](img/telar2.png){width=\"48%\"}](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom)\n\nMuestras de tejidos Telar de Jacquard (1801) - Nota de prensa [(Science and Industry Museum - Manchester)](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom).\n:::\n\n---\n\n::: {#fig-telar-jaq-3}\n[![](img/telar3.png){width=\"30%\"}](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom)\n\nMuestras de tarjetas Telar de Jacquard (1801) - Nota de prensa [(Science and Industry Museum - Manchester)](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom).\n:::\n\n---\n\n::: {#fig-telar-jaq-4}\n[![](img/telar4.png){width=\"70%\"}](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom)\n\nMuestras de tejidos Telar de Jacquard (1801) - Nota de prensa [(Science and Industry Museum - Manchester)](https://www.scienceandindustrymuseum.org.uk/objects-and-stories/jacquard-loom).\n:::\n\n---\n\n::: {#fig-aengine}\n![](img/analytical-engine.png){width=\"70%\"}\n\nCharles Babbage - Analytical Engine (1837).\n:::\n\n---\n\n::: {#fig-hollerith}\n[![](img/censo1890.png){width=\"70%\"}](https://www.columbia.edu/cu/computinghistory/census-tabulator.html)\n\nMáquina tabuladora Censo (1890) - Hollerith [(Columbia Edu)](https://www.columbia.edu/cu/computinghistory/census-tabulator.html).\n:::\n\n## Hollerith y el Censo de 1890\n\n- La máquina de Hollerith permitió a la oficina de estadísticas de Estados Unidos finalizar el censo en 6 meses y 2 años de análisis de datos. En referencia al censo de 1880 fue un exito considerando que este demoró 8 años. \n- El uso de tarjetas perforadas se mantuvo en el desarrollo de la computación, programación y análisis de datos, con aplicaciones concretas. Una de las empresas asociadas al uso de esta máquina fue la multinacional IBM.\n\n---\n\n::: {#fig-punchedc}\n![](img/punchedcard.png){width=\"70%\"}\n\nTarjetas perforadas - IBM (siglo XX).\n:::\n\n## La programación y sus aplicaciones \n\n- Estos ejemplos muestran como la programación ha estado relacionada desde sus origenes con la automatización de procesos (sobre todo en el ámbito industrial) y el análisis de datos sociodemográficos para la administración del Estado. \n- Otro caso relevante, es el uso militar de la tecnología de programación y computación, donde la Máquina de Turing (1936). Acá el desafío es no solo el cálculo sino también el manejo de valores lógicos, más cercano a la computación actual.  \n\n## Programación y algortimos\n\n- El primer algoritmo escrito directamente para una computación automatizada es el algoritmo publicado por **Ada Lovelace** en 1843 para el cálculo de números de Bernoulli. \n- Charles Babbage fue invitado a explicar el funcionamiento de la *Analytical Engine* y un matemático, Luigi Menabrea, escribió una nota al respecto en francés. Se pidió a Ada la traducción y que añadiera notas. Estas eran 3 veces más largas que el artículo original. \n\n## Programación y algortimos\n\n- En la Nota G, Lovelace describe como puede hacerse uso de esta máquina, mediante su operación binaria, para realizar cómputos avanzados. \n- La ecuación propuesta era recursiva, pues utilizaba la información de una operación para realizar la siguiente. \n- Según la autora, al hacer un uso binario de las tarjetas perforadas, se abrían posibilidades como el componer y elaborar *piezas científicas de música* de cualquier grado de complejidad.    \n\n---\n\n::: {#fig-punchedc}\n![](img/ada.jpg){width=\"70%\"}\n\nAda Lovelave - 1834\n:::\n\n## ¿Cómo utilizar funciones y algoritmos?\n\n- Recordemos que un *algoritmo* es una serie de instrucciones paso a paso para resolver un problema o realizar una tarea.\n- Una *función* es una forma concreta de escribir y reutilizar ese algoritmo dentro de un programa.\n- ¿Cómo podemos recurrir al uso de funciones y algoritmos para nuestro trabajo cotidiano?\n- ¿Qué procesos nos pueden ayudar a automatizar?  \n- ¿Que son los loops o iteraciones de código?\n\n## Funciones en R\n\n- En este caso entenderemos una función como un código para ser usado con una variedad de imputs y evita que debamos escribir el mismo código una y otra vez.\n- Recordemos que R es un lenguaje de programación entre otros lenguajes existentes como Python, C, etc. \n- Cada lenguaje de programación tiene reglas y formas de programación que definen estilos y formas particulares.\n\n## Estructura de una función básica\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1\"}\nnombre<-function(variables){\ncuerpo\n}\n```\n:::\n\n\n\n## Ejemplo con dataset df_personas\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1\"}\ndf_personas <- data.frame(\n  ID = 1:10,\n  Nombre = c(\"Ana\",\"Luis\",\"Eva\",\"Diego\",\"Juan\",\"Marcela\",\"Diego\",\"Jocelyn\",\"Raquel\",\"Alejandra\"),\n  Edad = c(28,34,39,45,14,65,52,27,62,28),\n  Ocupación = c(TRUE,TRUE,FALSE,TRUE,FALSE,FALSE,TRUE,FALSE,FALSE,TRUE),\n  Ingreso = c(510636,600000,80000,420000,224004,70000,530000,50000,224004,380000),\n  Gasto = c(700000,900000,120000,920000,200000,300000,1130000,600000,700000,880000)\n)\n```\n:::\n\n\n\n## Función ejemplo para estadísticas de resumen\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1\"}\n#Escribimos la función\nresumen <- function(vector){\n    maximo <-max(vector)\n    media <-mean(vector)\n    mediana <- median(vector)\n    minimo <- min(vector)\n    return(c(maximo,media,mediana,minimo))\n}\n```\n:::\n\n\n\n## Función aplicamos función a vectores edad, ingreso y gasto\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1\"}\n#Aplicamos sobre el vector \nedad<-as.vector(df_personas$Edad)\nprint(resumen(edad))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 65.0 39.4 36.5 14.0\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"1\"}\ningreso<-as.vector(df_personas$Ingreso)\nprint(resumen(ingreso))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 600000.0 308864.4 302002.0  50000.0\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"1\"}\ngasto<-as.vector(df_personas$Gasto)\nprint(resumen(gasto))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1130000  645000  700000  120000\n```\n\n\n:::\n:::\n\n\n\n## Función intervalo de confianza\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1\"}\nmean_ci <- function(x, conf = 0.95) {\n  se <- sd(x) / sqrt(length(x))\n  alpha <- 1 - conf\n  mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1\"}\nmean_ci(edad)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 29.1856 49.6144\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"1\"}\nmean_ci(ingreso)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 181068.2 436660.6\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"1\"}\nmean_ci(gasto)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 435137.4 854862.6\n```\n\n\n:::\n:::\n\n\n\n## Funciones anidadas\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1\"}\nresumen <- function(vector){\n  mean_ci <- function(x, conf = 0.95) {\n  se <- sd(x) / sqrt(length(x))\n  alpha <- 1 - conf\n  mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))\n  }\n    interval <-mean_ci(vector)\n    maximo <-max(vector)\n    media <-mean(vector)\n    mediana <- median(vector)\n    minimo <- min(vector)\n    return(c(maximo,media,mediana,minimo,interval))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1\"}\nprint(resumen(edad))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 65.0000 39.4000 36.5000 14.0000 29.1856 49.6144\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"1\"}\nprint(resumen(ingreso))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 600000.0 308864.4 302002.0  50000.0 181068.2 436660.6\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"1\"}\nprint(resumen(gasto))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1130000.0  645000.0  700000.0  120000.0  435137.4  854862.6\n```\n\n\n:::\n:::\n\n\n## Aplicar una función a una lista de vectores\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1\"}\nlista<-list(a=edad,b=ingreso,c=gasto)\nlapply(lista,resumen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 65.0000 39.4000 36.5000 14.0000 29.1856 49.6144\n\n$b\n[1] 600000.0 308864.4 302002.0  50000.0 181068.2 436660.6\n\n$c\n[1] 1130000.0  645000.0  700000.0  120000.0  435137.4  854862.6\n```\n\n\n:::\n:::\n\n\n\n## ¿Qué es un loop?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1\"}\nfor (i in 1:5) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n## Siguiendo el ejemplo anterior, en lugar de lapply con un loop\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1\"}\nfor (element in lista) {\n  print(resumen(element))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 65.0000 39.4000 36.5000 14.0000 29.1856 49.6144\n[1] 600000.0 308864.4 302002.0  50000.0 181068.2 436660.6\n[1] 1130000.0  645000.0  700000.0  120000.0  435137.4  854862.6\n```\n\n\n:::\n:::\n\n\n\n## Aplicar función según condición \n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1\"}\nocupa <- ifelse(df_personas$Ocupación == TRUE, \"Ocupado/a\", \"No ocupado/a\")\nocupa2 <-as.vector(df_personas$Ocupación)\nocupa2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}